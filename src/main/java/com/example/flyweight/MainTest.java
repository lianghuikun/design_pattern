package com.example.flyweight;

/**
 * 场景：flyweight(享元模式)，意思是轻量级
 *  内存属于稀缺资源，不要随便浪费。如果有很多个完全相同
 *  或者相似的对象，我们可以通过享元模式，节省内存
 *  以时间换空间
 * 核心：
 *  享元模式以共享的方式高效的支持大量细粒度对象的重用
 *  享元对象能做到共享的关键是区分了内部状态和外部状态。
 *      内部状态：可以共享，不会随环境变化而变化
 *      外部状态：不可以共享，会随环境变化而变化
 *      享元模式共享的是内部状态。
 * 围棋软件的设计：
 *      颜色、形状、大小，这些是可以共享的，为内部状态
 *      位置，是不可以共享的，称之为外部状态，需要传递过来
 *      大量白色的可以共享，大量黑色的也可以共享。
 * 享元模式的实现：
 *      FlyweightFactory享元工厂类
 *          创建并管理享元对象，享元池一般设计成键值对(map)
 *      Flyweight抽象享元类
 *          通常是一个接口或抽象类，声明公共方法，这些方法可以
 *          向外界提供对象的内部状态，设置外部状态
 *      ConcreteFlyWeight具体享元类(即内部状态类）
 *          为内部状态提供成员变量进行存储
 *      UnsharedConcreteFlyWeight非共享享元类(即外部状态类)
 *          不能被共享的子类可以设计为非共享享元类
 * 享元模式需要和工厂类搭配使用
 *
 * 享元模式开发中应用的场景：
 *      享元模式由于共享的特性，可以在任何池中操作，
 *      比如线程池、数据连接池
 *      String类的设计也是享元模式
 *  优点：
 *      极大减少了内存中对象的数量
 *      相同或相似对象内存中只存一份，极大的节约了资源，提高了性能
 *      外部状态相对独立，不影响内部状态
 *  缺点：
 *      模式较为复杂，使程序逻辑复杂化
 *      为了节省内存，共享了内部状态，分离了外部状态，而读取外部状态，
 *      使运行时间变长，用时间换空间
 */
public class MainTest {
    public static void main(String[] args) {
        Chese c1  = ChessFactory.getChess("黑色");
        Chese c2  = ChessFactory.getChess("黑色");
        System.out.println(c1);
        System.out.println(c2);
        System.out.println("添加外部状态的处理");
        c1.display(new Coordinate(10, 10));
        c1.display(new Coordinate(20, 20));
    }
}
